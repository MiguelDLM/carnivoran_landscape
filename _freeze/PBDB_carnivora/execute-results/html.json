{
  "hash": "86b39c08c7fa7186a8bb74f7cc009038",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Carnivoran data PBDB\"\nsubtitle: \"Download and filter carnivoran data from the Palaeobiology Database\"\nauthor: \"\"\ndate: \"2025-09-02\"\nformat:\n  html:\n    theme: cosmo\n    toc: true\n    code-fold: true\nexecute:\n  echo: true\n  warning: false\n  eval: false\n---\n\n\n\n\n\n# Carnivoran sample analysis\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Packages used in this tutorial\npackages <- c(\"tidyverse\", \"sf\", \"ggplot2\", \"ggthemes\", \"readr\",\"taxize\", \"plotly\")\n\n# Install missing packages (only the first time)\npackages_no_installed <- packages[!(packages %in% installed.packages()[, \"Package\"])]\nif (length(packages_no_installed)) install.packages(packages_no_installed)\n\n# Load packages\ninvisible(lapply(packages, require, character.only = TRUE))\n```\n:::\n\n\n\n\n\n## Analysis Parameters\n\nModify these variables for your analysis: `group` (taxon), `interval` (geological interval) and `time` (age in Ma)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parameters: change them according to what you want \ngroup <- \"carnivora\"    # base name for PBDB\ninterval <- \"cenozoic\"    # interval (e.g. 'miocene', 'oligocene')\n```\n:::\n\n\n\n\n\n# Taxonomy\n\nDo a request to the PBDB API to retrieve taxonomy information for the filtered taxa.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Build taxonomy URL safely: remove accidental spaces in the `show` parameter\nshow_fields <- \"attr,app,common,parent,immparent,classext\"\ntaxonomy_url <- paste0(\n  \"https://paleobiodb.org/data1.2/taxa/list.csv?name=\",\n  URLencode(group),\n  \"&rel=all_children&show=\",\n  URLencode(show_fields)\n)\n\nmessage(\"Downloading PBDB taxonomy data from: \", taxonomy_url)\ntaxonomy_data <- tryCatch(\n  read_csv(taxonomy_url, show_col_types = FALSE),\n  error = function(e) {\n    stop(\"Error downloading PBDB taxonomy data: \", e$message)\n  }\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter to keep only species-level taxa\ntaxonomy_filtered <- taxonomy_data %>%\n  filter(accepted_rank == \"species\") %>%\n  distinct(accepted_name, .keep_all = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Enriquecimiento de `taxonomy_filtered` con niveles taxonómicos obtenidos por taxize\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(tidyr)\n\n# Vector de nombres a consultar (especies filtradas)\ntaxa_vector <- taxonomy_filtered$accepted_name\n\n# Función auxiliar: intenta varios servicios hasta obtener un resultado\nget_classification_safe <- function(taxon) {\n  dbs <- c(\"itis\", \"ncbi\", \"gbif\")\n  for (db in dbs) {\n    res <- tryCatch(taxize::classification(taxon, db = db), error = function(e) NULL)\n    if (!is.null(res) && length(res) > 0) {\n      # taxize puede devolver lista; extraer primer elemento si es necesario\n      df <- if (is.list(res) && !is.data.frame(res)) res[[1]] else res\n      if (is.data.frame(df) && nrow(df) > 0) return(df)\n    }\n  }\n  return(NULL)\n}\n\n# Rangos que queremos como columnas\nranks_want <- c(\"kingdom\", \"phylum\", \"class\", \"order\", \"family\", \"genus\", \"species\")\n\n# Consulta todas las especies (puede tardar; considera cachear)\nupstream_list <- purrr::map(taxa_vector, get_classification_safe)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convertir la lista de clasificaciones a un dataframe ancho (una fila por taxón)\ntax_df <- purrr::map2_dfr(taxa_vector, upstream_list, ~{\n  taxon_name <- .x\n  cl <- .y\n  if (is.null(cl) || nrow(cl) == 0) {\n    # fila vacía con solo el nombre\n    tibble(accepted_name = taxon_name)\n  } else {\n  }\n})\n\n# Hacer left join para enriquecer taxonomy_filtered\ntaxonomy_enriched <- taxonomy_filtered %>%\n  left_join(tax_df, by = \"accepted_name\")\n\n# Mostrar un resumen\nmessage(\"Taxonomy enriched: \", nrow(taxonomy_enriched), \" rows; sample:\")\nprint(head(taxonomy_enriched))\n```\n:::\n\n\n\n\n\n# load the mandibles data and combine\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#load the mandibles.xlsx file\nlibrary(readxl)\nmandibles_data <- read_excel(\"mandibles.xlsx\")\n#create a new column combining genus and species\nmandibles_data <- mandibles_data %>%\n  mutate(Species2 = paste(Genus, Species, sep = \" \"))\n\n# Asegurar que mandibles_data tenga Species2 (si se puede construir)\nif (!\"Species2\" %in% names(mandibles_data) && all(c(\"Genus\",\"Species\") %in% names(mandibles_data))) {\n  mandibles_data$Species2 <- paste(mandibles_data$Genus, mandibles_data$Species)\n}\n\n# Crear columna availability comprobando membership fuera de mutate evitando NSE\nmandibles_dataset <- taxonomy_enriched %>%\n  mutate(availability = ifelse(accepted_name %in% mandibles_data$Species2, \"Chatar\", \"\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#load RData\nload(\"PBDB_carnivora_env.RData\")\n```\n:::\n\n\n\n\n\n\n# Interactive Plots\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plotly)\n\n# Prepare data for interactive plots  \nmandibles_dataset <- mandibles_dataset %>% \n  mutate(family = family.y, genus = genus.y)\n\n# Species per family (count unique species) - Interactive\nspecies_summary <- mandibles_dataset %>%\n  group_by(family, availability) %>%\n  summarise(n_species = n_distinct(accepted_name), .groups = \"drop\") %>%\n  arrange(family, availability)\n\nfamily_totals <- species_summary %>% \n  group_by(family) %>% \n  summarise(total = sum(n_species), .groups = \"drop\") %>%\n  arrange(desc(total))\n\n# Create interactive stacked bar chart for species\np1 <- plot_ly(\n  data = species_summary,\n  x = ~n_species,\n  y = ~factor(family, levels = family_totals$family),\n  color = ~availability,\n  colors = c(\"Chatar\" = \"#228B22\", \"\" = \"#DC143C\"),  # Green for Chatar, Red for empty\n  type = \"bar\",\n  orientation = \"h\",\n  hovertemplate = \"<b>%{y}</b><br>Availability: %{fullData.color}<br>Species: %{x}<extra></extra>\"\n) %>%\n  layout(\n    title = \"Species Availability per Family\",\n    xaxis = list(title = \"Number of Species\"),\n    yaxis = list(title = \"Family\"),\n    barmode = \"stack\",\n    hovermode = \"closest\"\n  )\n\np1\n\n# Genus per family (count distinct genera within each family) - Interactive  \ngenus_summary <- mandibles_dataset %>%\n  group_by(family, availability) %>%\n  summarise(n_genera = n_distinct(genus), .groups = \"drop\") %>%\n  arrange(family, availability)\n\ngenus_totals <- genus_summary %>% \n  group_by(family) %>% \n  summarise(total = sum(n_genera), .groups = \"drop\") %>%\n  arrange(desc(total))\n\n# Create interactive stacked bar chart for genera\np2 <- plot_ly(\n  data = genus_summary,\n  x = ~n_genera,\n  y = ~factor(family, levels = genus_totals$family),\n  color = ~availability,\n  colors = c(\"Chatar\" = \"#228B22\", \"\" = \"#DC143C\"),  # Green for Chatar, Red for empty\n  type = \"bar\", \n  orientation = \"h\",\n  hovertemplate = \"<b>%{y}</b><br>Availability: %{fullData.color}<br>Genera: %{x}<extra></extra>\"\n) %>%\n  layout(\n    title = \"Genera per Family\", \n    xaxis = list(title = \"Number of Genera\"),\n    yaxis = list(title = \"Family\"),\n    barmode = \"stack\",\n    hovermode = \"closest\"\n  )\n\np2\n```\n:::\n\n\n\n\n\n# Interactive Sunburst Chart\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Interactive sunburst chart (3-level): Root > Family > Availability > Extant Status\nlibrary(plotly)\nlibrary(dplyr)\n\n# Prepare data for sunburst: ensure we have the columns and clean values\nmandibles_dataset <- mandibles_dataset %>%\n  mutate(\n    family = ifelse(is.na(family.y) | family.y == \"\", \"Unknown\", as.character(family.y)),\n    availability = ifelse(is.na(availability) | availability == \"\", \"No Data\", \n                         ifelse(availability == \"Chatar\", \"Chatar\", \"No Data\")),\n    is_extant = ifelse(is.na(is_extant) | is_extant == \"\", \"Unknown\", as.character(is_extant))\n  )\n\n# Build hierarchical data structure for sunburst\n# Level 1: Root (center)\n# Level 2: Families \n# Level 3: Availability within families\n# Level 4: Extant status within availability\n\n# Count species at each level\nspecies_counts <- mandibles_dataset %>%\n  group_by(family, availability, is_extant) %>%\n  summarise(n_species = n_distinct(accepted_name), .groups = \"drop\") %>%\n  filter(n_species > 0)\n\n# Create sunburst data structure\nsunburst_data <- tibble(\n  ids = character(),\n  labels = character(), \n  parents = character(),\n  values = numeric(),\n  colors = character()\n)\n\n# Root node\nsunburst_data <- sunburst_data %>%\n  add_row(ids = \"Carnivora\", labels = \"Carnivora\", parents = \"\", \n          values = sum(species_counts$n_species), colors = \"#CCCCCC\")\n\n# Family level nodes\nfamily_data <- species_counts %>%\n  group_by(family) %>%\n  summarise(total_species = sum(n_species), .groups = \"drop\") %>%\n  arrange(desc(total_species))\n\nfor(fam in family_data$family) {\n  total_sp <- family_data$total_species[family_data$family == fam]\n  sunburst_data <- sunburst_data %>%\n    add_row(ids = fam, labels = paste0(fam, \"<br>(\", total_sp, \" spp)\"), \n            parents = \"Carnivora\", values = total_sp, colors = \"#888888\")\n}\n\n# Availability level nodes  \navail_data <- species_counts %>%\n  group_by(family, availability) %>%\n  summarise(total_species = sum(n_species), .groups = \"drop\")\n\nfor(i in 1:nrow(avail_data)) {\n  fam <- avail_data$family[i]\n  avail <- avail_data$availability[i]\n  total_sp <- avail_data$total_species[i]\n  node_id <- paste(fam, avail, sep = \" - \")\n  \n  color <- ifelse(avail == \"Chatar\", \"#228B22\", \"#DC143C\")  # Green for Chatar, Red for No Data\n  \n  sunburst_data <- sunburst_data %>%\n    add_row(ids = node_id, labels = paste0(avail, \"<br>(\", total_sp, \" spp)\"),\n            parents = fam, values = total_sp, colors = color)\n}\n\n# Extant status level nodes (leaf nodes)\nfor(i in 1:nrow(species_counts)) {\n  fam <- species_counts$family[i]\n  avail <- species_counts$availability[i]\n  extant <- species_counts$is_extant[i]\n  n_sp <- species_counts$n_species[i]\n  \n  parent_id <- paste(fam, avail, sep = \" - \")\n  node_id <- paste(fam, avail, extant, sep = \" - \")\n  \n  # Colors for extant status\n  color <- case_when(\n    extant == \"extant\" ~ \"#4169E1\",    # Blue for extant\n    extant == \"extinct\" ~ \"#FFD700\",   # Gold for extinct  \n    TRUE ~ \"#D3D3D3\"                   # Light gray for unknown\n  )\n  \n  sunburst_data <- sunburst_data %>%\n    add_row(ids = node_id, labels = paste0(extant, \"<br>(\", n_sp, \" spp)\"),\n            parents = parent_id, values = n_sp, colors = color)\n}\n\n# Create interactive sunburst chart\nfig <- plot_ly(\n  type = \"sunburst\",\n  ids = sunburst_data$ids,\n  labels = sunburst_data$labels, \n  parents = sunburst_data$parents,\n  values = sunburst_data$values,\n  branchvalues = \"total\",\n  hovertemplate = \"<b>%{label}</b><br>Species: %{value}<br>Percentage: %{percentParent}<extra></extra>\",\n  maxdepth = 4,\n  insidetextorientation = 'radial'\n) %>%\n  layout(\n    title = list(\n      text = \"Interactive Carnivoran Species Distribution\",\n      font = list(size = 16)\n    ),\n    font = list(size = 12),\n    margin = list(t = 50, l = 0, r = 0, b = 0)\n  )\n\nfig\n```\n:::\n\n\n\n\n\n# Load Ann's data\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load Ann's data from the csv file\nann_data <- read.csv(\"Ann-jaws.csv\")    \n# add column name to first column\ncolnames(ann_data)[1] <- \"Species\"\n# Replace \"_\" with spaces\nann_data$Species <- gsub(\"_\", \" \", ann_data$Species)\n#save csv\nwrite.csv(ann_data, \"Ann-jaws.csv\", row.names = FALSE)\n```\n:::\n\n\n\n\n\n# Merge data\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Enriquecer mandibles_dataset con información de Ann (similar a como se hizo con Chatar)\n# Crear vector de especies de Ann para búsqueda rápida\nann_species <- unique(ann_data$Species)\n\n# Añadir información de Ann a mandibles_dataset\nmandibles_dataset <- mandibles_dataset %>%\n  mutate(\n    # Marcar si la especie está disponible en la base de datos de Ann\n    ann_available = case_when(\n      accepted_name %in% ann_species ~ \"Ann\",\n      TRUE ~ \"\"\n    ),\n    # Actualizar columna availability: si ya tenía \"Chatar\" y también está en Ann, crear nota\n    note = case_when(\n      availability == \"Chatar\" & ann_available == \"Ann\" ~ \"Also available in Ann\",\n      TRUE ~ NA_character_\n    ),\n    # Actualizar availability: priorizar Ann si está disponible, sino mantener valor original\n    availability = case_when(\n      ann_available == \"Ann\" ~ \"Ann\",\n      TRUE ~ availability\n    )\n  )\n```\n:::",
    "supporting": [
      "PBDB_carnivora_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}